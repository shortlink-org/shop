// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: query.sql

package crud

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgconn"
	"github.com/jackc/pgx/v5/pgtype"
	"github.com/shopspring/decimal"
)

const countOrders = `-- name: CountOrders :one
SELECT COUNT(*) FROM oms.orders
`

func (q *Queries) CountOrders(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countOrders)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countOrdersByCustomer = `-- name: CountOrdersByCustomer :one
SELECT COUNT(*) FROM oms.orders WHERE customer_id = $1
`

func (q *Queries) CountOrdersByCustomer(ctx context.Context, customerID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countOrdersByCustomer, customerID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countOrdersByStatus = `-- name: CountOrdersByStatus :one
SELECT COUNT(*) FROM oms.orders WHERE status = ANY($1::int[])
`

func (q *Queries) CountOrdersByStatus(ctx context.Context, dollar_1 []int32) (int64, error) {
	row := q.db.QueryRow(ctx, countOrdersByStatus, dollar_1)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countOrdersWithFilters = `-- name: CountOrdersWithFilters :one
SELECT COUNT(*) FROM oms.orders WHERE customer_id = $1 AND status = ANY($2::int[])
`

type CountOrdersWithFiltersParams struct {
	CustomerID uuid.UUID
	Column2    []int32
}

func (q *Queries) CountOrdersWithFilters(ctx context.Context, arg CountOrdersWithFiltersParams) (int64, error) {
	row := q.db.QueryRow(ctx, countOrdersWithFilters, arg.CustomerID, arg.Column2)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const deleteOrderDeliveryInfo = `-- name: DeleteOrderDeliveryInfo :exec
DELETE FROM oms.order_delivery_info
WHERE order_id = $1
`

func (q *Queries) DeleteOrderDeliveryInfo(ctx context.Context, orderID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteOrderDeliveryInfo, orderID)
	return err
}

const deleteOrderItems = `-- name: DeleteOrderItems :exec
DELETE FROM oms.order_items
WHERE order_id = $1
`

func (q *Queries) DeleteOrderItems(ctx context.Context, orderID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteOrderItems, orderID)
	return err
}

const getOrder = `-- name: GetOrder :one
SELECT id, customer_id, status, version, created_at, updated_at
FROM oms.orders
WHERE id = $1
`

func (q *Queries) GetOrder(ctx context.Context, id uuid.UUID) (OmsOrder, error) {
	row := q.db.QueryRow(ctx, getOrder, id)
	var i OmsOrder
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.Status,
		&i.Version,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getOrderDeliveryInfo = `-- name: GetOrderDeliveryInfo :one
SELECT 
    order_id,
    pickup_street, pickup_city, pickup_postal_code, pickup_country, pickup_latitude, pickup_longitude,
    delivery_street, delivery_city, delivery_postal_code, delivery_country, delivery_latitude, delivery_longitude,
    period_start, period_end,
    weight_kg, dimensions,
    priority, package_id
FROM oms.order_delivery_info
WHERE order_id = $1
`

func (q *Queries) GetOrderDeliveryInfo(ctx context.Context, orderID uuid.UUID) (OmsOrderDeliveryInfo, error) {
	row := q.db.QueryRow(ctx, getOrderDeliveryInfo, orderID)
	var i OmsOrderDeliveryInfo
	err := row.Scan(
		&i.OrderID,
		&i.PickupStreet,
		&i.PickupCity,
		&i.PickupPostalCode,
		&i.PickupCountry,
		&i.PickupLatitude,
		&i.PickupLongitude,
		&i.DeliveryStreet,
		&i.DeliveryCity,
		&i.DeliveryPostalCode,
		&i.DeliveryCountry,
		&i.DeliveryLatitude,
		&i.DeliveryLongitude,
		&i.PeriodStart,
		&i.PeriodEnd,
		&i.WeightKg,
		&i.Dimensions,
		&i.Priority,
		&i.PackageID,
	)
	return i, err
}

const getOrderItems = `-- name: GetOrderItems :many
SELECT good_id, quantity, price
FROM oms.order_items
WHERE order_id = $1
`

type GetOrderItemsRow struct {
	GoodID   uuid.UUID
	Quantity int32
	Price    decimal.Decimal
}

func (q *Queries) GetOrderItems(ctx context.Context, orderID uuid.UUID) ([]GetOrderItemsRow, error) {
	rows, err := q.db.Query(ctx, getOrderItems, orderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOrderItemsRow
	for rows.Next() {
		var i GetOrderItemsRow
		if err := rows.Scan(&i.GoodID, &i.Quantity, &i.Price); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertOrder = `-- name: InsertOrder :exec
INSERT INTO oms.orders (id, customer_id, status, version, created_at, updated_at)
VALUES ($1, $2, $3, 1, NOW(), NOW())
`

type InsertOrderParams struct {
	ID         uuid.UUID
	CustomerID uuid.UUID
	Status     string
}

func (q *Queries) InsertOrder(ctx context.Context, arg InsertOrderParams) error {
	_, err := q.db.Exec(ctx, insertOrder, arg.ID, arg.CustomerID, arg.Status)
	return err
}

const insertOrderDeliveryInfo = `-- name: InsertOrderDeliveryInfo :exec
INSERT INTO oms.order_delivery_info (
    order_id,
    pickup_street, pickup_city, pickup_postal_code, pickup_country, pickup_latitude, pickup_longitude,
    delivery_street, delivery_city, delivery_postal_code, delivery_country, delivery_latitude, delivery_longitude,
    period_start, period_end,
    weight_kg, dimensions,
    priority, package_id
) VALUES (
    $1,
    $2, $3, $4, $5, $6, $7,
    $8, $9, $10, $11, $12, $13,
    $14, $15,
    $16, $17,
    $18, $19
)
`

type InsertOrderDeliveryInfoParams struct {
	OrderID            uuid.UUID
	PickupStreet       pgtype.Text
	PickupCity         pgtype.Text
	PickupPostalCode   pgtype.Text
	PickupCountry      pgtype.Text
	PickupLatitude     pgtype.Numeric
	PickupLongitude    pgtype.Numeric
	DeliveryStreet     string
	DeliveryCity       string
	DeliveryPostalCode pgtype.Text
	DeliveryCountry    string
	DeliveryLatitude   pgtype.Numeric
	DeliveryLongitude  pgtype.Numeric
	PeriodStart        pgtype.Timestamptz
	PeriodEnd          pgtype.Timestamptz
	WeightKg           pgtype.Numeric
	Dimensions         pgtype.Text
	Priority           string
	PackageID          pgtype.UUID
}

func (q *Queries) InsertOrderDeliveryInfo(ctx context.Context, arg InsertOrderDeliveryInfoParams) error {
	_, err := q.db.Exec(ctx, insertOrderDeliveryInfo,
		arg.OrderID,
		arg.PickupStreet,
		arg.PickupCity,
		arg.PickupPostalCode,
		arg.PickupCountry,
		arg.PickupLatitude,
		arg.PickupLongitude,
		arg.DeliveryStreet,
		arg.DeliveryCity,
		arg.DeliveryPostalCode,
		arg.DeliveryCountry,
		arg.DeliveryLatitude,
		arg.DeliveryLongitude,
		arg.PeriodStart,
		arg.PeriodEnd,
		arg.WeightKg,
		arg.Dimensions,
		arg.Priority,
		arg.PackageID,
	)
	return err
}

const insertOrderItem = `-- name: InsertOrderItem :exec
INSERT INTO oms.order_items (order_id, good_id, quantity, price)
VALUES ($1, $2, $3, $4)
`

type InsertOrderItemParams struct {
	OrderID  uuid.UUID
	GoodID   uuid.UUID
	Quantity int32
	Price    decimal.Decimal
}

func (q *Queries) InsertOrderItem(ctx context.Context, arg InsertOrderItemParams) error {
	_, err := q.db.Exec(ctx, insertOrderItem,
		arg.OrderID,
		arg.GoodID,
		arg.Quantity,
		arg.Price,
	)
	return err
}

const listOrders = `-- name: ListOrders :many
SELECT id, customer_id, status, version, created_at, updated_at
FROM oms.orders
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListOrdersParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) ListOrders(ctx context.Context, arg ListOrdersParams) ([]OmsOrder, error) {
	rows, err := q.db.Query(ctx, listOrders, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []OmsOrder
	for rows.Next() {
		var i OmsOrder
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.Status,
			&i.Version,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrdersByCustomer = `-- name: ListOrdersByCustomer :many
SELECT id, customer_id, status, version, created_at, updated_at
FROM oms.orders
WHERE customer_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListOrdersByCustomer(ctx context.Context, customerID uuid.UUID) ([]OmsOrder, error) {
	rows, err := q.db.Query(ctx, listOrdersByCustomer, customerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []OmsOrder
	for rows.Next() {
		var i OmsOrder
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.Status,
			&i.Version,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrdersWithCustomerFilter = `-- name: ListOrdersWithCustomerFilter :many
SELECT id, customer_id, status, version, created_at, updated_at
FROM oms.orders
WHERE customer_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListOrdersWithCustomerFilterParams struct {
	CustomerID uuid.UUID
	Limit      int32
	Offset     int32
}

func (q *Queries) ListOrdersWithCustomerFilter(ctx context.Context, arg ListOrdersWithCustomerFilterParams) ([]OmsOrder, error) {
	rows, err := q.db.Query(ctx, listOrdersWithCustomerFilter, arg.CustomerID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []OmsOrder
	for rows.Next() {
		var i OmsOrder
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.Status,
			&i.Version,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrdersWithFilters = `-- name: ListOrdersWithFilters :many
SELECT id, customer_id, status, version, created_at, updated_at
FROM oms.orders
WHERE customer_id = $1 AND status = ANY($2::int[])
ORDER BY created_at DESC
LIMIT $3 OFFSET $4
`

type ListOrdersWithFiltersParams struct {
	CustomerID uuid.UUID
	Column2    []int32
	Limit      int32
	Offset     int32
}

func (q *Queries) ListOrdersWithFilters(ctx context.Context, arg ListOrdersWithFiltersParams) ([]OmsOrder, error) {
	rows, err := q.db.Query(ctx, listOrdersWithFilters,
		arg.CustomerID,
		arg.Column2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []OmsOrder
	for rows.Next() {
		var i OmsOrder
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.Status,
			&i.Version,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrdersWithStatusFilter = `-- name: ListOrdersWithStatusFilter :many
SELECT id, customer_id, status, version, created_at, updated_at
FROM oms.orders
WHERE status = ANY($1::int[])
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListOrdersWithStatusFilterParams struct {
	Column1 []int32
	Limit   int32
	Offset  int32
}

func (q *Queries) ListOrdersWithStatusFilter(ctx context.Context, arg ListOrdersWithStatusFilterParams) ([]OmsOrder, error) {
	rows, err := q.db.Query(ctx, listOrdersWithStatusFilter, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []OmsOrder
	for rows.Next() {
		var i OmsOrder
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.Status,
			&i.Version,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateOrder = `-- name: UpdateOrder :execresult
UPDATE oms.orders
SET status = $2, version = $3, updated_at = NOW()
WHERE id = $1 AND version = $4
`

type UpdateOrderParams struct {
	ID        uuid.UUID
	Status    string
	Version   int32
	Version_2 int32
}

func (q *Queries) UpdateOrder(ctx context.Context, arg UpdateOrderParams) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, updateOrder,
		arg.ID,
		arg.Status,
		arg.Version,
		arg.Version_2,
	)
}

const updateOrderDeliveryInfo = `-- name: UpdateOrderDeliveryInfo :exec
UPDATE oms.order_delivery_info
SET 
    pickup_street = $2, pickup_city = $3, pickup_postal_code = $4, pickup_country = $5, pickup_latitude = $6, pickup_longitude = $7,
    delivery_street = $8, delivery_city = $9, delivery_postal_code = $10, delivery_country = $11, delivery_latitude = $12, delivery_longitude = $13,
    period_start = $14, period_end = $15,
    weight_kg = $16, dimensions = $17,
    priority = $18, package_id = $19
WHERE order_id = $1
`

type UpdateOrderDeliveryInfoParams struct {
	OrderID            uuid.UUID
	PickupStreet       pgtype.Text
	PickupCity         pgtype.Text
	PickupPostalCode   pgtype.Text
	PickupCountry      pgtype.Text
	PickupLatitude     pgtype.Numeric
	PickupLongitude    pgtype.Numeric
	DeliveryStreet     string
	DeliveryCity       string
	DeliveryPostalCode pgtype.Text
	DeliveryCountry    string
	DeliveryLatitude   pgtype.Numeric
	DeliveryLongitude  pgtype.Numeric
	PeriodStart        pgtype.Timestamptz
	PeriodEnd          pgtype.Timestamptz
	WeightKg           pgtype.Numeric
	Dimensions         pgtype.Text
	Priority           string
	PackageID          pgtype.UUID
}

func (q *Queries) UpdateOrderDeliveryInfo(ctx context.Context, arg UpdateOrderDeliveryInfoParams) error {
	_, err := q.db.Exec(ctx, updateOrderDeliveryInfo,
		arg.OrderID,
		arg.PickupStreet,
		arg.PickupCity,
		arg.PickupPostalCode,
		arg.PickupCountry,
		arg.PickupLatitude,
		arg.PickupLongitude,
		arg.DeliveryStreet,
		arg.DeliveryCity,
		arg.DeliveryPostalCode,
		arg.DeliveryCountry,
		arg.DeliveryLatitude,
		arg.DeliveryLongitude,
		arg.PeriodStart,
		arg.PeriodEnd,
		arg.WeightKg,
		arg.Dimensions,
		arg.Priority,
		arg.PackageID,
	)
	return err
}

// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: query.sql

package crud

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgconn"
	"github.com/shopspring/decimal"
)

const deleteOrderItems = `-- name: DeleteOrderItems :exec
DELETE FROM oms.order_items
WHERE order_id = $1
`

func (q *Queries) DeleteOrderItems(ctx context.Context, orderID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteOrderItems, orderID)
	return err
}

const getOrder = `-- name: GetOrder :one
SELECT id, customer_id, status, version, created_at, updated_at
FROM oms.orders
WHERE id = $1
`

func (q *Queries) GetOrder(ctx context.Context, id uuid.UUID) (OmsOrder, error) {
	row := q.db.QueryRow(ctx, getOrder, id)
	var i OmsOrder
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.Status,
		&i.Version,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getOrderItems = `-- name: GetOrderItems :many
SELECT good_id, quantity, price
FROM oms.order_items
WHERE order_id = $1
`

type GetOrderItemsRow struct {
	GoodID   uuid.UUID
	Quantity int32
	Price    decimal.Decimal
}

func (q *Queries) GetOrderItems(ctx context.Context, orderID uuid.UUID) ([]GetOrderItemsRow, error) {
	rows, err := q.db.Query(ctx, getOrderItems, orderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOrderItemsRow
	for rows.Next() {
		var i GetOrderItemsRow
		if err := rows.Scan(&i.GoodID, &i.Quantity, &i.Price); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertOrder = `-- name: InsertOrder :exec
INSERT INTO oms.orders (id, customer_id, status, version, created_at, updated_at)
VALUES ($1, $2, $3, 1, NOW(), NOW())
`

type InsertOrderParams struct {
	ID         uuid.UUID
	CustomerID uuid.UUID
	Status     string
}

func (q *Queries) InsertOrder(ctx context.Context, arg InsertOrderParams) error {
	_, err := q.db.Exec(ctx, insertOrder, arg.ID, arg.CustomerID, arg.Status)
	return err
}

const insertOrderItem = `-- name: InsertOrderItem :exec
INSERT INTO oms.order_items (order_id, good_id, quantity, price)
VALUES ($1, $2, $3, $4)
`

type InsertOrderItemParams struct {
	OrderID  uuid.UUID
	GoodID   uuid.UUID
	Quantity int32
	Price    decimal.Decimal
}

func (q *Queries) InsertOrderItem(ctx context.Context, arg InsertOrderItemParams) error {
	_, err := q.db.Exec(ctx, insertOrderItem,
		arg.OrderID,
		arg.GoodID,
		arg.Quantity,
		arg.Price,
	)
	return err
}

const listOrdersByCustomer = `-- name: ListOrdersByCustomer :many
SELECT id, customer_id, status, version, created_at, updated_at
FROM oms.orders
WHERE customer_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListOrdersByCustomer(ctx context.Context, customerID uuid.UUID) ([]OmsOrder, error) {
	rows, err := q.db.Query(ctx, listOrdersByCustomer, customerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []OmsOrder
	for rows.Next() {
		var i OmsOrder
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.Status,
			&i.Version,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateOrder = `-- name: UpdateOrder :execresult
UPDATE oms.orders
SET status = $2, version = $3, updated_at = NOW()
WHERE id = $1 AND version = $4
`

type UpdateOrderParams struct {
	ID        uuid.UUID
	Status    string
	Version   int32
	Version_2 int32
}

func (q *Queries) UpdateOrder(ctx context.Context, arg UpdateOrderParams) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, updateOrder,
		arg.ID,
		arg.Status,
		arg.Version,
		arg.Version_2,
	)
}
